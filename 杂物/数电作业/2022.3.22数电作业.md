# 第二次作业 2022.3.22

## 1. 列举三种处理器架构，并结合某一种架构说明每个功能模块的功能

当前市场上流动最广的三类芯片的架构分别为：

- intel 12代酷睿的 Golden Cove架构
- AMD 锐龙的 Zen3+架构
- 苹果M1 芯片的 ARM 架构

以使用率最高的 **i7-12700H为例**：

> 计算核心的电路看起来很复杂，但其实根据功能模块，可以将其划分为
>
> - 指令拾取单元（Instruction Fetch Unit）
> - 微操作调度单元（uOP Scheduler）
> - 乱序调度单元（OOO Scheduler）
> - 标量/向量/甚至矩阵计算单元（Scalar/Vector/Marix Engine）
> - 缓存子系统（Memory Subsystem）
> - 电源管理单元（PM）
>
> 这几个部分。根据新的制程工艺和电路设计方式，对这些部分逐个进行优化和性能提升，最终就能够实现CPU Core IPC性能的提升。
>
> 当然，Intel在新的Golden Cove核心上还根据应用需求增加了新的功能模块。为应对AI计算快速增大的代码规模和越来越大的数据集，Intel通过在每个计算核心上增加**单独的矩阵计算引擎**来加速AI模型计算；为提高每比特的功耗性能，Intel采用了新的**智能电源管理控制器（Power Management Controller）**，从而进行更加精细化的功率管理。

## 2、结合某一具体处理器，说明处理器的流水线

> **流水线(Pipeline)**技术是指程序在执行时候多条指令重叠进行操作的一种准并行处理实现技术。通俗的讲将一个时序过程，分解成若干个子过程，每个过程都能有效的与其他子过程同时执行。这种思想最初是在RISC的架构中出现的，旨在提高处理器处理效率，争取在一个时钟周期中完成一条指令。

因为现在CPU流水线技术属于商业机密，因此很难找到当下使用的CPU作为案例。

因此，接下来将会以 Intel I486为例：

I486 拥有五级流水线。分别是：取指(Fetch)，译码(D1, main decode)，转址(D2, translate)，执行(EX, execute)，写回(WB)。某个指令可以在流水线的任何一级。

　第一步是第一条指令进入取指阶段；然后在第二步第一条指令进入译码阶段，同时第二条指令进入取指阶段；第三步第一条指令进入转址阶段，第二条指令进入译码阶段，第三条指令进入取指阶段。但是在第四步会出现问题，第一条指令会进入执行阶段，而其他指令却不能继续向前移动。第二条 xor 指令需要第一条 xor 指令计算的结果a，但是直到第一条指令执行完成才会写回。所以流水线的其他指令就会在当前流水级等待直到第一条指令的执行和写回阶段完成。第二条指令会等待第一条指令完成才能进入流水线下一级，同样第三条指令也要等待第二条指令完成。

　　这个现象被称为流水线阻塞或者流水线气泡。

　　另外一个关于流水线的问题是有些指令执行速度快，有些指令执行速度慢。

更形象一点：

​		首先，你是一条指令，你所属的程序正在运行。

　　你一直在耐心的等待指令指针会指向自己，等待被 CPU 运行。当指令指针距离你还有 4KB 远的时候（这大约是 1500 条指令），你被 CPU 从内存取到指令缓存中。虽然从内存加载进入指令缓存需要一段时间，但是现在距离你被执行的时刻还很远，你有足够的时间。这个预取的过程属于流水线的第一级。

　　当指令指针离你越来越近，距离你还有 24 条指令的时候，你和你旁边的 5 个指令会被放到指令队列里面。

　　这个处理器有 4 个译码器，可以容纳一个复杂指令和最多三个简单指令。你碰巧是一条复杂指令，通过译码，你被翻译成 4 个微指令。

　　译码的过程可以划分为多步。译码过程中的一步是检查你需要的数据和猜测你可能会产生一个地址跳转。译码器一旦检测到需要的额外数据，不需要让你知道，这个数据就开始从内存加载到数据缓存中了。

　　你的四个微指令到达寄存器重命名表。你告诉它你需要读哪个内存地址（比如说 fs:[eax+18h]），然后寄存器重命名表将这个地址转换为临时地址供微指令使用。地址转化完成后，你的微指令将进入重排序缓存(Reorder Buffer, ROB)并记录指令次序。接着第一时间进入保留站(Reservation Station, RS)。

　　保留站用于存储已经准备就绪可以执行的指令。你的第三条微指令被立即选中并送往端口5，这个端口直接执行运算。但是你并不知道为什么它会被首先选中，无论如何，它确实被执行了。几个时钟周期之后你的第一条微指令前往端口2，该端口是读单元(Load Address execution unit)。剩余的微指令一直等待，同时各个端口正在收集不同的微指令。他们都在等待端口 2 将数据从缓存和内存中加载进来并放在临时存储空间内。

　　他们等了很久……

　　相当久的时间……

　　不过在他们等待第一条微指令返回数据的时候，又有其他的新指令又进来。好在处理器知道如何让这些指令乱序执行（即后到达保留站的微指令被优先执行）。

　　当第一条微指令返回了数据，剩余的两条微指令被立即送往执行端口 0 和1。现在这 4 条微指令都已经运行，最终它们会返回保留站。

　　这些微指令返回后交出他们的“票”并给出各自的临时地址。通过这些地址，你作为一个完整的指令，将他们合并。最后 CPU 将结果交给你并使你退出。

　　当你到达标有“退出”的门的时候，你会发现这里要排一个队列。你进入后发现你刚好站在你前面进来指令的后面，即使执行中的顺序可能已经不同，但你们退出的顺序继续保持一致。看来乱序执行部件真正知道自己做了什么。

　　每条指令最终离开 CPU，每次一条指令，就和指令指针指向的顺序一样！



这就是处理器的流水线模型。



## 3. 课后习题

### 2.7 利用反演法求下列函数的反函数

$$
1. F=A\bar B + \bar AB \\
\bar F= (\bar A + B)(\bar B + A)
\\
\\
2.F=AB+(\bar A+B)(C+D+E) \\
\bar F=(\bar A + \bar B)(A\bar B + \bar C \bar D \bar E)\\
\\
3.F = ABC+AB \bar C +A \bar BC+ A\bar B\bar C\\
\bar F = (\bar A+\bar B+\bar C)(\bar A+\bar B+C)(\bar A+B+\bar C)(\bar A+B+C)\\
\\
4.F=(A+B\bar C)(\bar A+\bar DE)\\
\bar F= (\bar A(\bar B+C))+(A(D+\bar E))\\
\\
5.F=\overline{\bar A\bar B+ABC}(B+CD)\\
\bar F = \bar A\bar B+ABC+\bar B(\bar C+\bar D) \\
\\
6.F=A\bigoplus \bar B\bigoplus1\\
\bar F=\bar A\bar B+AB
$$





### 2.8 写出下列格式的对偶式

$$
1. F=(A+B)(\bar A+C)(C+DE)+H\\
F^{'}=(AB+\bar AC+C(D+E))H\\
\\
2.F=A(B+\bar C)+\bar AB(C+\bar D)+A\bar BC+\bar DE(A+B)\\
F'=(A+B\bar C)(\ (\bar A+\bar B)+C\bar D)(A+\bar B+C)(\bar D+E+AB)\\
\\
3.F=\overline{\overline{A\bar B}\times \overline{C\bar D}\times D\overline{AB}}\\
F'=\overline{\overline{A+\bar B}+ \overline{C+\bar D}+ D+\overline{A+B}}\\
\\
4.F=A+B(\bar C+E\bar H)\\
F'=AB+\bar C(E+\bar H)\\
\\
5.F=\overline{\overline{(\overline {A+B})+(\overline{C+D})}+\overline{(\overline{E+H})+(\overline{J+K})}}\\
F'=\overline{\overline{(\overline {AB})(\overline{CD})}\times \overline{(\overline{EH})(\overline{JK})}}\\
\\
6.F = X_2\overline{(X_1\bigoplus X_0)}+\bar X_2(X_1\bigoplus X_0)\\
F'=(X_2+\overline{(X_1\bigodot X_0)})(\bar X_2+(X_1\bigodot X_0))\\
$$



### 2.13写出下列格式的最小项表达式和最大项表达式

$$
1. F(A,B)= \sum m(1,2) = \bar AB +A\bar B\\
=\prod M(0,3) = (A+B)(\bar A+\bar B)\\
\\
2.F(A,B) = \prod M(0,1,2) = (A+B)(A+\bar B)(\bar A+B)\\
=\sum M(3) = (\bar A+\bar B)\\
\\
3.F(A,B,C)=\sum m(2,4,6,7) = \bar AB\bar C+A\bar B\bar C+AB\bar C+ABC\\
=\prod M(0,1,3,5) = (A+B+C)(A+B+\bar C)(A+\bar B+\bar C)(\bar A+B+\bar C)\\
\\
4.F(A,B,C)=\prod M(0,1,3,4,5)=(A+B+C)(A+B+\bar C)\times\\(A+\bar B+\bar C)(\bar A+B+C)(\bar A+B+\bar C)\\
=\sum m(2,6,7) =\bar AB\bar C+AB\bar C+ABC\\
\\
5.(A,B,C) = A+\bar B\bar C = \bar A\bar B\bar C+A\bar B\bar C+ABC+AB\bar C+A\bar BC\\
=\sum m^3(0,1,2,3,4) = \prod M^3(5,6,7)\\
=(\bar A+B+\bar C)(\bar A+\bar B+C)(\bar A+\bar B+\bar C)\\
\\
6.F(A,B,C)=\bar A +(\overline{\bar BC}) = \bar A+B+\bar C\\
=\bar ABC+\bar AB\bar C+\bar A\bar BC+\bar A\bar B\bar C
+ABC+AB\bar C+A\bar B\bar C\\
=\sum m^3(0,102,3,4,6,7) = \prod M^3(5)\\
$$



### 2.14将下列函数展开为最小项之和

$$
1.F = AB+\bar A\bar B+C\bar D\\
=ABCD+ABC\bar D+AB\bar CD+AB\bar C\bar D\\+
\bar A\bar BCD+\bar A\bar BC\bar D+\bar A\bar B\bar CD+\bar A\bar B\bar C\bar D\\+\bar ABC\bar D+A\bar BC\bar D\\
\\
2.F=A(\bar B+CD)+\bar ABCD\\
=A\bar B+ACD+\bar ABCD\\=A\bar BCD+A\bar BC\bar D+A\bar B\bar CD+A\bar B\bar C\bar D\\+ABCD+\bar ABCD\\
\\
3.F=\overline{AC+\bar BD+AD}\\
=(\bar A+\bar C)(B+\bar D)(\bar A+\bar D)\\
=(\bar AB+\bar A\bar D+ \bar CB+\bar CD)(\bar A+\bar D)\\
=\bar AB+\bar A\bar D+\bar AB\bar C+\bar A\bar CD+\bar AB\bar D+\bar A\bar D+B\bar C\bar D\\
=\bar ABCD+\bar ABC\bar D+\bar AB\bar CD+\bar AB\bar C\bar D\\
+\bar A\bar BC\bar D+\bar A\bar B\bar C\bar D+\bar A\bar BC\bar D+AB\bar C\bar D\\
\\
4.F=\overline{(AB+ABD)}(B+CD)=(\bar A+\bar B)(B+CD) =\bar AB+\bar ACD+\bar BCD\\=\bar ABCD+\bar ABC\bar D+\bar AB\bar CD+\bar AB\bar C\bar D\\+\bar A\bar BCD+A\bar BCD
$$

### 2.15 将下列函数展开为最大项之积

$$
1.F=A\bigoplus B+\overline{AC} = \bar A+\bar B+\bar C\\
\\
2.F=(\bar A+C)(A+B)(C+\bar D) \\=
(\bar A+B+C+D)(\bar A+B+C+\bar D)(\bar A+\bar B+C+D)(\bar A+\bar B+C+\bar D)\\\times(A+B+C+D)(A+B+C+\bar D)(A+B+\bar C+D)(A+B+\bar C+\bar D)\\\times(A+\bar B+C+\bar D)\\
\\
3.F=\bar AD+\bar BD+\bar BC\bar D\\=(A+\bar B+C+D)(A+\bar B+\bar C+D)(\bar A+B+C+D)\\\times(\bar A+\bar B+C+D)(\bar A+\bar B+C+\bar D)(\bar A+\bar B+\bar C+D)(\bar A+\bar B+\bar C+\bar D)\\
\\
4.F=(\bar A\bigoplus B)(A\bigoplus \bar B)+B\bigoplus C\bigoplus D\\
=(\bar A\bar B+AB)(\bar A\bar B+AB)+(\bar BC+B\bar C)\bar D+\overline{(\bar BC+B\bar C)}D\\
=\bar A\bar B+AB+\bar BC\bar D+B\bar C\bar D+BCD+\bar B\bar CD\\
=\sum m(0,1,2,3,12,13,14,15)+\sum m(2,10,4,12,7,15,1,9)\\
=\sum m(0,1,2,3,4,7,9,10,12,13,14,15)
=\prod M(5,6,8,11)\\=(A+\bar B+C+\bar D)(A+\bar B+\bar C+D)(\bar A+B+C+D)(\bar A+B+\bar C+\bar D)
$$

### 2.18用卡诺图化简下列各式为最简与或式

#### 1. $$ F=\sum m^3(1,3,5,6,7) = C+AB\bar C $$

![image-20220409121049476](C:\Users\Administrator.Bili-2021PEFKBB\AppData\Roaming\Typora\typora-user-images\image-20220409121049476.png)

#### 2. $$ F=\sum m^4(1,4,5,6,7,9,14,15)=BC+\bar B\bar C D+\bar AB\bar C $$ 

![image-20220409122405034](C:\Users\Administrator.Bili-2021PEFKBB\AppData\Roaming\Typora\typora-user-images\image-20220409122405034.png)
