## Day1 二分查找
 #算法 #查找算法 #二分查找
 ---

### #leet 704 .二分查找
#### 思路：

每次与数组的中间值比较后一分为二递归，对左右子列分别调用函数。

- 基准情形：
	 1. 当中间值正好等于目标值时返回中间值的索引
	 2. 当子列只剩一个值且与目标值不相等时返回 -1
- 不断推进：
	将数列一分为二，按情况对左右子列分别递归使用二分查找

#### code：

```java
class Solution {

	public int search(int[] nums, int target) {

 		return searchNum(nums , target , 0 , nums.length - 1);

	}

  

	public int searchNum(int[] nums , int target , int left , int right){

 	// if there is no element or only one element: finish finding

		if(left == right){

			if(target == nums[left]){

				return left;

			}

			else{

				return -1;

				}

			}

		//if there is more than one elements : continue finding

		else{

			 if(target > nums[(left + right) / 2]){

			 return searchNum(nums , target , ((left + right) / 2) + 1, right);

			 }

			 else if(target < nums[(left + right) / 2]){

				 return searchNum(nums , target , left , ((left + right) / 2));

			 }

			 else{

				 return (left + right) / 2;

			 }

		 }

	}

}
```

#### Debug

##### 死循环问题：
当子数组仅有两个元素时发生了死循环。
*bug代码：*
```java
 if(target > nums[(left + right) / 2]){
			//这里产生了死循环：
			 return searchNum(nums , target , ((left + right) / 2) , right);

			 }

			 else if(target < nums[(left + right) / 2]){

				 return searchNum(nums , target , left , ((left + right) / 2));

			 }
```

		这里需要判断中间值的归属。 
		由于 (0+1) / 2 的值为 0，（偶数个元素的数列求得的中间值始终在左侧）因此为了满足基准情形的推出条件（左右指针相同），需要将这个值归属到左子列的行列中，而右子列不包含这个值。

#### 官方解答
##### 思路：

1. 这里要注意left 与 right 相等的情况在[left,right]区间是有意义的，所以while（left<=right）条件要使用<=
2. 二分查找要定义中间的指针 middle = (right-left)/2+left
3. 如果nums[middle]==target(需要查找的值) ，返回下标middle
4. 如果nums[middle]>target,这时left指针不动，让right指针改变，变为right=middle-1，即将中间指针向左移动一个赋值为right
5. 如果nums[middle]<target,这时right指针不动，让left指针改变，变为leftt=middle+1，即将中间指针向右边移动一个赋值为left
6. 其他情况找不到就返回-1

作者：strange-ramanujanovh
链接：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xie-fa-yi-java-by-strang-udg3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


##### code:

```java
class Solution {
    public int search(int[] nums, int target) {
        int low = 0, high = nums.length - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            int num = nums[mid];
            if (num == target) {
                return mid;
            } else if (num > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```


### #leet 278.一个错误的版本

#### 思路：

同 #leet 704 。这次用移动指针的方法实现。

#### code：

```java
/* The isBadVersion API is defined in the parent class VersionControl.

 boolean isBadVersion(int version); */

  

public class Solution extends VersionControl {

	 public int firstBadVersion(int totalVersion) {

		 long rightIndex = totalVersion;

		 long leftIndex = 1;



		 while(leftIndex < rightIndex){

			 if(isBadVersion((int)((rightIndex + leftIndex) / 2))){

			 rightIndex = (rightIndex + leftIndex) / 2;

			 }

			 else{

			 leftIndex = (rightIndex + leftIndex) / 2 + 1;

			 }

		 }
		 return (int)leftIndex;

	}

}
```


#### Debug

##### 死循环问题：

while发生死循环。测试数据：

	2126753390 
	1702766719
	
*问题：int范围越界。*
**解决：调整数据类型。**
int 类型数据的范围： [-2^31~2^31-1] 、 -2147483648~2147483647

#### 官方解答：
##### 思路：
因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。

注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。

具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。

这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧$$O(\log n)$$ 次。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


##### code:

```java
lass Solution {
public:
    int firstBadVersion(int n) {
        int left = 1, right = n;
        while (left < right) { // 循环直至区间左右端点相同
            int mid = left + (right - left) / 2; // 防止计算时溢出
            if (isBadVersion(mid)) {
                right = mid; // 答案在区间 [left, mid] 中
            } else {
                left = mid + 1; // 答案在区间 [mid+1, right] 中
            }
        }
        // 此时有 left == right，区间缩为一个点，即为答案
        return left;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### #leet 35.搜索插入位置

#### 思路：
同 #leet 704 。计算中间值用$$mid = left + (right - left) / 2$$
这个题在我2021.10时候做过。。。

#### code:
```java
class Solution { 
	
	private int left = 0; 
	private int right = 0; 
	private int mid = 0; 
	
	public int searchInsert(int[] nums, int target) { 
		this.LR(nums); 
		return this.search(nums,target); 
	} 
	
	private void LR(int[] nums){ 
		left = 0; 
		right = nums.length-1; 
	} 
	
	private boolean half(int[] nums , int target){ 
		mid = left + (right - left)/2; 
		if(target == nums[mid]){ 
			return true; 
		} 
		else if(target > nums[mid]){ 
			left = mid; 
		} 
		else{ 
			right = mid; 
		} 
		return false; 
	} 
	
	private int search(int[] nums, int target){ 
		while(right - left > 1){ 
			if(this.half(nums,target)){ 
				return mid; 
			} 
		} 
		if(target <= nums[left]){ 
			return left; 
		} 
		else if(target > nums[right]){ 
			return right+1; 
		} 
		else{ 
			return right; 
		} 
	} 
}
```

**No Bugs!**


## Day2 双指针
#算法 #双指针 
---
###  #leet 977 有序数组的平方
#### 思路：
先对数组中的每个元素做平方处理，之后对数组中的元素进行重新排序。这里可选的排序方法有很多。由于原数组的性质，我们可以采用双指针相向移动的方法对数组进行排序。

#### 代码：
```java
class Solution {

 	public int[] sortedSquares(int[] nums) {

 		//平方处理

		 for(int index = 0; index <= nums.length - 1; index++){

 			nums[index] *= nums[index];

 		}

  

 		//排序处理

 		int left = 0;

 		int right = nums.length - 1;

 		int[] ans = new int[nums.length];

 		int index = nums.length - 1;

  

 		while(left <= right){

 			if(nums[left] > nums[right]){

 				ans[index--] = nums[left++];

 			}

  

			 else{

 				ans[index--] = nums[right--];

 			}

 		}

 		return ans;

 	}

}
```

#### Debug:
**No Bugs**

#### 官方解答：1.直接排序
1. 这是最直观的思路:
将数组 nums 中的数平方后直接排序, 同样因为使用了排序算法, 时间和空间复杂度都非常高.

2. 双指针思想
数组原本是有序的, 只是在平方之后就变得无序了, 根本原因就是负数平方之后可能成为最大数了, 那么数组平方的最大值就在数组的两端, 不是最左边就是最右边, 不可能是中间.

这样我们就能确定了平方后最大值的位置, 所以用双指针指向数组的两端, 必定能找到平方后的最大值, 将其放到新数组末尾, 之后不断向中间移动, 通过比较两个指针平方后的大小, 就能不断地将当前的最大值放入数组的尾部, 直到两个指针相遇为止.

这种一种比较简单的双指针实现方式, 另外一种稍微麻烦一点的方式就是 先找到负值和正值的分界点, 相当于找到了平方后的最小值, 然后向两边不断进行遍历, 不过这种方法还多了一层循环来找分界点, 这种思想也要了解一下, 对于之后的题目还是挺有用的.


### #leet 189 轮转数组
#### 思路：
通过循环数组的方式找到轮转后数组的开端，之后按顺序输出即可。

#### 代码
```java
class Solution {

 	public void rotate(int[] nums, int k) {

 	//采用循环队列的方式进行轮转

 	//只需要计算出队列的头元素在哪里就可以实现循环队列的轮转

  

		int[] ans = nums.clone();

		int font = nums.length;

		font -= k;

		while(font < 0){

			font += nums.length;

		}



		for(int index = 0; index <= nums.length - 1; index++){

			nums[index] = ans[(font + index) % nums.length];

		}

  

 	}

  

}
```

#### Debug
- 算法没什么问题，出现最后数组拷贝时的问题： $$ nums = ans$$部分报错，这里采用从ans copy到nums数组的方式。具体BUG内容需要调试。

#### 官方解答
方法一：使用额外的数组
我们可以使用额外的数组来将每个元素放至正确的位置。用 nn 表示数组的长度，我们遍历原数组，将原数组下标为 ii 的元素放至新数组下标为$$ (i+k)\bmod n(i+k)modn$$ 的位置，最后将新数组拷贝至原数组即可。

复杂度分析

时间复杂度： O(n)，其中 n 为数组的长度。

空间复杂度： O(n)。

方法二：环状替换
方法一中使用额外数组的原因在于如果我们直接将每个数字放至它最后的位置，这样被放置位置的元素会被覆盖从而丢失。因此，从另一个角度，我们可以将被替换的元素保存在变量 \textit{temp}temp 中，从而避免了额外数组的开销。

我们从位置 0开始，最初令$$ \textit{temp}=\textit{nums}[0]temp=nums[0]。$$根据规则，位置 0的元素会放至 $$(0+k)\bmod n(0+k) mod n$$ 的位置，令 $$x=(0+k)\bmod nx=(0+k)modn$$，此时交换 $$\textit{temp}temp 和 \textit{nums}[x]nums[x]$$，完成位置 x 的更新。然后，我们考察位置 x，并交换 $$\textit{temp}temp 和 \textit{nums}[(x+k)\bmod n]nums[(x+k)modn]$$从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置 0。

容易发现，当回到初始位置 00 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从 00 开始不断遍历，最终回到起点 00 的过程中，我们遍历了多少个元素？

由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为 a 圈；再设该过程总共遍历了 b 个元素。因此，我们有 $$an=bkan=bk$$即 an 一定为 n,kn,k 的公倍数。又因为我们在第一次回到起点时就结束，因此 a 要尽可能小，故 an 就是 n,kn,k 的最小公倍数 $$\text{lcm}(n,k)lcm(n,k)$$，因此 b就为 $$\text{lcm}(n,k)/klcm(n,k)/k$$。

这说明单次遍历会访问到 $$\text{lcm}(n,k)/klcm(n,k)/k$$ 个元素。为了访问到所有的元素，我们需要进行遍历的次数为

$$\frac{n}{\text{lcm}(n,k)/k}=\frac{nk}{\text{lcm}(n,k)}=\text{gcd}(n,k)
lcm(n,k)/k
n
​
 = 
lcm(n,k)
nk
​
 =gcd(n,k)
							  $$

其中 $$\text{gcd}$$ 指的是最大公约数。

我们用下面的例子更具体地说明这个过程：


nums = [1, 2, 3, 4, 5, 6]
k = 2


如果读者对上面的数学推导的理解有一定困难，也可以使用另外一种方式完成代码：使用单独的变量 $$\textit{count}count$$ 跟踪当前已经访问的元素数量，当 $$\textit{count}=ncount=n$$ 时，结束遍历过程。
