## Day1 二分查找
 #算法 #查找算法 #二分查找
 ---

### #leet 704 .二分查找
#### 思路：

每次与数组的中间值比较后一分为二递归，对左右子列分别调用函数。

- 基准情形：
	 1. 当中间值正好等于目标值时返回中间值的索引
	 2. 当子列只剩一个值且与目标值不相等时返回 -1
- 不断推进：
	将数列一分为二，按情况对左右子列分别递归使用二分查找

#### code：

```java
class Solution {

	public int search(int[] nums, int target) {

 		return searchNum(nums , target , 0 , nums.length - 1);

	}

  

	public int searchNum(int[] nums , int target , int left , int right){

 	// if there is no element or only one element: finish finding

		if(left == right){

			if(target == nums[left]){

				return left;

			}

			else{

				return -1;

				}

			}

		//if there is more than one elements : continue finding

		else{

			 if(target > nums[(left + right) / 2]){

			 return searchNum(nums , target , ((left + right) / 2) + 1, right);

			 }

			 else if(target < nums[(left + right) / 2]){

				 return searchNum(nums , target , left , ((left + right) / 2));

			 }

			 else{

				 return (left + right) / 2;

			 }

		 }

	}

}
```

#### Debug

##### 死循环问题：
当子数组仅有两个元素时发生了死循环。
*bug代码：*
```java
 if(target > nums[(left + right) / 2]){
			//这里产生了死循环：
			 return searchNum(nums , target , ((left + right) / 2) , right);

			 }

			 else if(target < nums[(left + right) / 2]){

				 return searchNum(nums , target , left , ((left + right) / 2));

			 }
```

		这里需要判断中间值的归属。 
		由于 (0+1) / 2 的值为 0，（偶数个元素的数列求得的中间值始终在左侧）因此为了满足基准情形的推出条件（左右指针相同），需要将这个值归属到左子列的行列中，而右子列不包含这个值。

#### 官方解答
##### 思路：

1. 这里要注意left 与 right 相等的情况在[left,right]区间是有意义的，所以while（left<=right）条件要使用<=
2. 二分查找要定义中间的指针 middle = (right-left)/2+left
3. 如果nums[middle]==target(需要查找的值) ，返回下标middle
4. 如果nums[middle]>target,这时left指针不动，让right指针改变，变为right=middle-1，即将中间指针向左移动一个赋值为right
5. 如果nums[middle]<target,这时right指针不动，让left指针改变，变为leftt=middle+1，即将中间指针向右边移动一个赋值为left
6. 其他情况找不到就返回-1

作者：strange-ramanujanovh
链接：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xie-fa-yi-java-by-strang-udg3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


##### code:

```java
class Solution {
    public int search(int[] nums, int target) {
        int low = 0, high = nums.length - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            int num = nums[mid];
            if (num == target) {
                return mid;
            } else if (num > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```


### #leet 278.一个错误的版本

#### 思路：

同 #leet 704 。这次用移动指针的方法实现。

#### code：

```java
/* The isBadVersion API is defined in the parent class VersionControl.

 boolean isBadVersion(int version); */

  

public class Solution extends VersionControl {

	 public int firstBadVersion(int totalVersion) {

		 long rightIndex = totalVersion;

		 long leftIndex = 1;



		 while(leftIndex < rightIndex){

			 if(isBadVersion((int)((rightIndex + leftIndex) / 2))){

			 rightIndex = (rightIndex + leftIndex) / 2;

			 }

			 else{

			 leftIndex = (rightIndex + leftIndex) / 2 + 1;

			 }

		 }
		 return (int)leftIndex;

	}

}
```


#### Debug

##### 死循环问题：

while发生死循环。测试数据：

	2126753390 
	1702766719
	
*问题：int范围越界。*
**解决：调整数据类型。**
int 类型数据的范围： [-2^31~2^31-1] 、 -2147483648~2147483647

#### 官方解答：
##### 思路：
因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。

注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。

具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。

这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧$$O(\log n)$$ 次。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


##### code:

```java
lass Solution {
public:
    int firstBadVersion(int n) {
        int left = 1, right = n;
        while (left < right) { // 循环直至区间左右端点相同
            int mid = left + (right - left) / 2; // 防止计算时溢出
            if (isBadVersion(mid)) {
                right = mid; // 答案在区间 [left, mid] 中
            } else {
                left = mid + 1; // 答案在区间 [mid+1, right] 中
            }
        }
        // 此时有 left == right，区间缩为一个点，即为答案
        return left;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### #leet 35.搜索插入位置

#### 思路：
同 #leet 704 。计算中间值用$$mid = left + (right - left) / 2$$
这个题在我2021.10时候做过。。。

#### code:
```java
class Solution { 
	
	private int left = 0; 
	private int right = 0; 
	private int mid = 0; 
	
	public int searchInsert(int[] nums, int target) { 
		this.LR(nums); 
		return this.search(nums,target); 
	} 
	
	private void LR(int[] nums){ 
		left = 0; 
		right = nums.length-1; 
	} 
	
	private boolean half(int[] nums , int target){ 
		mid = left + (right - left)/2; 
		if(target == nums[mid]){ 
			return true; 
		} 
		else if(target > nums[mid]){ 
			left = mid; 
		} 
		else{ 
			right = mid; 
		} 
		return false; 
	} 
	
	private int search(int[] nums, int target){ 
		while(right - left > 1){ 
			if(this.half(nums,target)){ 
				return mid; 
			} 
		} 
		if(target <= nums[left]){ 
			return left; 
		} 
		else if(target > nums[right]){ 
			return right+1; 
		} 
		else{ 
			return right; 
		} 
	} 
}
```

**No Bugs!**


## Day2 双指针
#算法 #双指针 

---

###  #leet 977 有序数组的平方
#### 思路：
先对数组中的每个元素做平方处理，之后对数组中的元素进行重新排序。这里可选的排序方法有很多。由于原数组的性质，我们可以采用双指针相向移动的方法对数组进行排序。

#### 代码：
```java
class Solution {

 	public int[] sortedSquares(int[] nums) {

 		//平方处理

		 for(int index = 0; index <= nums.length - 1; index++){

 			nums[index] *= nums[index];

 		}

  

 		//排序处理

 		int left = 0;

 		int right = nums.length - 1;

 		int[] ans = new int[nums.length];

 		int index = nums.length - 1;

  

 		while(left <= right){

 			if(nums[left] > nums[right]){

 				ans[index--] = nums[left++];

 			}

  

			 else{

 				ans[index--] = nums[right--];

 			}

 		}

 		return ans;

 	}

}
```

#### Debug:
**No Bugs**

#### 官方解答：1.直接排序
1. 这是最直观的思路:
将数组 nums 中的数平方后直接排序, 同样因为使用了排序算法, 时间和空间复杂度都非常高.

2. 双指针思想
数组原本是有序的, 只是在平方之后就变得无序了, 根本原因就是负数平方之后可能成为最大数了, 那么数组平方的最大值就在数组的两端, 不是最左边就是最右边, 不可能是中间.

这样我们就能确定了平方后最大值的位置, 所以用双指针指向数组的两端, 必定能找到平方后的最大值, 将其放到新数组末尾, 之后不断向中间移动, 通过比较两个指针平方后的大小, 就能不断地将当前的最大值放入数组的尾部, 直到两个指针相遇为止.

这种一种比较简单的双指针实现方式, 另外一种稍微麻烦一点的方式就是 先找到负值和正值的分界点, 相当于找到了平方后的最小值, 然后向两边不断进行遍历, 不过这种方法还多了一层循环来找分界点, 这种思想也要了解一下, 对于之后的题目还是挺有用的.


### #leet 189 轮转数组
#### 思路：
通过循环数组的方式找到轮转后数组的开端，之后按顺序输出即可。

#### 代码
```java
class Solution {

 	public void rotate(int[] nums, int k) {

 	//采用循环队列的方式进行轮转

 	//只需要计算出队列的头元素在哪里就可以实现循环队列的轮转

  

		int[] ans = nums.clone();

		int font = nums.length;

		font -= k;

		while(font < 0){

			font += nums.length;

		}



		for(int index = 0; index <= nums.length - 1; index++){

			nums[index] = ans[(font + index) % nums.length];

		}

  

 	}

  

}
```

#### Debug
- 算法没什么问题，出现最后数组拷贝时的问题： $$ nums = ans$$部分报错，这里采用从ans copy到nums数组的方式。具体BUG内容需要调试。

#### 官方解答
##### 方法一：使用额外的数组
我们可以使用额外的数组来将每个元素放至正确的位置。用 nn 表示数组的长度，我们遍历原数组，将原数组下标为 ii 的元素放至新数组下标为$$ (i+k)\bmod n(i+k)modn$$ 的位置，最后将新数组拷贝至原数组即可。

复杂度分析

时间复杂度： O(n)，其中 n 为数组的长度。

空间复杂度： O(n)。

###### 方法二：环状替换
方法一中使用额外数组的原因在于如果我们直接将每个数字放至它最后的位置，这样被放置位置的元素会被覆盖从而丢失。因此，从另一个角度，我们可以将被替换的元素保存在变量 \textit{temp}temp 中，从而避免了额外数组的开销。

我们从位置 0开始，最初令$$ \textit{temp}=\textit{nums}[0]temp=nums[0]。$$根据规则，位置 0的元素会放至 $$(0+k)\bmod n(0+k) mod n$$ 的位置，令 $$x=(0+k)\bmod nx=(0+k)modn$$，此时交换 $$\textit{temp}temp 和 \textit{nums}[x]nums[x]$$，完成位置 x 的更新。然后，我们考察位置 x，并交换 $$\textit{temp}temp 和 \textit{nums}[(x+k)\bmod n]nums[(x+k)modn]$$从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置 0。

容易发现，当回到初始位置 00 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从 00 开始不断遍历，最终回到起点 00 的过程中，我们遍历了多少个元素？

由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为 a 圈；再设该过程总共遍历了 b 个元素。因此，我们有 $$an=bkan=bk$$即 an 一定为 n,kn,k 的公倍数。又因为我们在第一次回到起点时就结束，因此 a 要尽可能小，故 an 就是 n,kn,k 的最小公倍数 $$\text{lcm}(n,k)lcm(n,k)$$，因此 b就为 $$\text{lcm}(n,k)/klcm(n,k)/k$$。

这说明单次遍历会访问到 $$\text{lcm}(n,k)/klcm(n,k)/k$$ 个元素。为了访问到所有的元素，我们需要进行遍历的次数为

$$\frac{n}{\text{lcm}(n,k)/k}=\frac{nk}{\text{lcm}(n,k)}=\text{gcd}(n,k)
lcm(n,k)/k
n
​
 = 
lcm(n,k)
nk
​
 =gcd(n,k)
							  $$

其中 $$\text{gcd}$$ 指的是最大公约数。

我们用下面的例子更具体地说明这个过程：


nums = [1, 2, 3, 4, 5, 6]
k = 2


如果读者对上面的数学推导的理解有一定困难，也可以使用另外一种方式完成代码：使用单独的变量 $$\textit{count}count$$ 跟踪当前已经访问的元素数量，当 $$\textit{count}=ncount=n$$ 时，结束遍历过程。


## Day 3 双指针
#算法 #双指针 

---
### #leet 283 移动零
#### 思路：
移动的过程中需要保证原数组的有序性，因此交换应该尽量发生在相邻元素之间。
只需要在每次检索的时候将 0 移动到数组的末尾即可。

#### 代码：
```java
class Solution {

 public void moveZeroes(int[] nums) {

 //保持排序的稳定性只能在相邻两个元素之间进行替换

 int left = nums.length - 1;

 while(left >= 0){

 if(nums[left] == 0){

 int right = left;

 while(right < nums.length - 1){

 int temp = nums[right];

 nums[right] = nums[right + 1];

 nums[right + 1] = temp;

 right ++;

 }

 }

 left --;

 }

 }

}
```

#### 官方思路：
双指针：
从左向右依次遍历。快指针检索当前的数是多少，慢指针只在快指针走到数组末或者快指针遇到一个非0数时前进。
如果快指针检索的当前值为非0值，将慢指针的当前值改为0后移动慢指针。
如果快指针检索当前值为0，继续检索
当快指针移动到数组末时，慢指针移动，并将沿途所有元素改为0.
**在数组中将所有非0元素移动到前面，而非将0移动到后面。**

### #leet 167两数之和II - 输入有序数组
#### 思路：
因为数组是有序的，因此我们只需要计算每次首尾元素相加后的和，之后比较大小即可。如果和更大，我们就向左移动指针；和小就向右移动指针。
#### code：
```Java
class Solution {

 public int[] twoSum(int[] numbers, int target) {

 int i = 0;

 int j = numbers.length - 1;

 while(numbers[i] + numbers[j] != target){

 if(numbers[i] + numbers[j] > target){

 j--;

 }

 else{

 i++;

 }

 }

 int[] ans = {i + 1 , j + 1};

 return ans;

 }

}
```

### #leet 344.反串字符串
#### 思路：
双指针颠倒顺序即可。
#### code：
```java
class Solution {

 public void reverseString(char[] s) {

 int left = 0;

 int right = s.length - 1;

  

 while(left < right){

 swap(s , left ++ , right --);

 }

 }

  

 public void swap(char [] s , int a , int b){

 char temp = s[a];

 s[a] = s[b];

 s[b] = temp;

 }

}
```

### #leet 557.反转字符串中的单词 Ⅲ
#### 思路：
用双指针寻找字符串中的每个单词的首尾，之后执行翻转操作。
#### 代码：
```java
class Solution {

 public String reverseWords(String s) {

 StringBuffer sb = new StringBuffer(s);

 int left = 0;

 int right = 0;

  

 while(left < sb.length()){

  

 if(sb.charAt(left) != ' '){

 while(right < sb.length() && sb.charAt(right) != ' '){

 right ++;

 }

 right -= 1;

 int next = right + 2;

 while(left < right){

 swap(sb , left++ , right --);

 }

 left = next;

 right = next;

 }

 else{

 left ++;

 }

 }

 return sb.toString();

 }

  

 public void swap(StringBuffer s , int left , int right){

 char temp = s.charAt(left);

 s.setCharAt(left , s.charAt(right));

 s.setCharAt(right , temp);

 }

}
```

### #leet 876 链表的中间节点
#### 思路：
**快慢指针法**
快指针走两步时慢指针走一步即可。

#### code：
```java
/**

 * Definition for singly-linked list.

 * public class ListNode {

 *     int val;

 *     ListNode next;

 *     ListNode() {}

 *     ListNode(int val) { this.val = val; }

 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }

 * }

 */

class Solution {

 public ListNode middleNode(ListNode head) {

 ListNode fast = head;

 ListNode slow = head;

  

 while(fast.next != null){

 fast = fast.next;

 if(fast.next != null){

 fast = fast.next;

 }

 slow = slow.next;

 }

 return slow;

 }

}
```

### #leet 19 删除链表的倒数第N个节点
#### 思路：
让快慢指针始终相差n个单位，当快指针走到末尾时，慢指针指的就是要删除的节点。（前驱比后继更重要，这里最好是设置一个dummyNode放在前面会方便很多。）

#### code：

```java 
/**

 * Definition for singly-linked list.

 * public class ListNode {

 *     int val;

 *     ListNode next;

 *     ListNode() {}

 *     ListNode(int val) { this.val = val; }

 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }

 * }

 */

class Solution {

 public ListNode removeNthFromEnd(ListNode head, int n) {

 ListNode fast = head;

 ListNode slow = head;

 int i = 0;

  

 while(++i < n && fast.next != null){

 fast = fast.next;

 }

 while(fast.next != null){

 fast = fast.next;

 slow = slow.next;

 }

  

 fast = head;

 if(slow == head){

 return slow.next;

 }

  

 while(fast.next != slow){

 fast = fast.next;

 }

 fast.next = fast.next.next;

 return head;

  

 }

}
```

#### Debug
- 这里在**特殊情况处理**的部分发生了很大的问题。
> 1. 当只有1个元素且删除这个元素时要返回空
> 
> 2. 当删除头元素时候不能返回头元素。

#### 官方思路：
这里可以采用**构造栈**的方式，十分方便。删除倒数第n个元素的思想刚好和栈吻合。


# Day4 滑动窗口
#滑动窗口 #算法

---
> 滑动窗口算法是在给定特定窗口大小的数组或字符串上执行要求的操作。
> 该技术可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。

>就像真的滑动窗户一样，控制左右指针（窗口） 在给定的数组集合上滑动来解决字数组的问题。

###  #leet 3.无重复字符的最长字串
没做出来，放官方解
#### 思路：
$$
以 \texttt{(a)bcabcbb} 开始的最长字符串为 \texttt{(abc)abcbb}；
$$
$$
以 \texttt{a(b)cabcbb} 开始的最长字符串为 \texttt{a(bca)bcbb}；
$$
$$
以 \texttt{ab(c)abcbb} 开始的最长字符串为 \texttt{ab(cab)cbb}；
$$
$$
以 \texttt{abc(a)bcbb} 开始的最长字符串为 \texttt{abc(abc)bb}；
$$
$$
以 \texttt{abca(b)cbb} 开始的最长字符串为 \texttt{abca(bc)bb}；
$$
$$
以 \texttt{abcab(c)bb} 开始的最长字符串为 \texttt{abcab(cb)b}；
$$
$$
以 \texttt{abcabc(b)b} 开始的最长字符串为 \texttt{abcabc(b)b}；
$$
$$
以 \texttt{abcabcb(b)} 开始的最长字符串为 \texttt{abcabcb(b)}。
$$

这样一来，我们就可以使用「滑动窗口」来解决这个问题了：

在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；

在枚举结束后，我们找到的最长的子串的长度即为答案。

在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。

#### code:
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 哈希集合，记录每个字符是否出现过
        Set<Character> occ = new HashSet<Character>();
        int n = s.length();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        for (int i = 0; i < n; ++i) {
            if (i != 0) {
                // 左指针向右移动一格，移除一个字符
                occ.remove(s.charAt(i - 1));
            }
            while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {
                // 不断地移动右指针
                occ.add(s.charAt(rk + 1));
                ++rk;
            }
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = Math.max(ans, rk - i + 1);
        }
        return ans;
    }
```


#### HashSet类

**构造方法**
```java
public HashSet(int c , float y)
	//构造一个 容量为 c ，负载因子为 y 的哈希集合
	//默认为 16 ， 0.75
```

**常用方法**
```java
boolean add(Object o)
	//判断元素o是否在集合中，如果不在则将o加入集合并返回true，在则返回false
boolean contains(Object o)
	//判断元素o是否在集合中
boolean remove(Object o)
	//判断元素o是否在集合中，如果在则将o删除并返回true，不在则返回false
int size()
	//返回集合中元素个数
Iterator iterator()
	//支持迭代器
void clear()
	//清空集合
```

**原理**
当hashset add一个元素A的时候，首先获取这个元素的散列码（hashcode的方法），即获取元素的哈希值。

- **情况一**：
如果计算出的元素的存储位置目前没有任何元素存储，那么该元素可以直接存储在该位置上。

- **情况二**
如果算出该元素的存储位置目前已经存在有其他元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的值是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行添加。


